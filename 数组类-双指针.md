# 数组类-双指针

标签（空格分隔）： 未分类

---

## 三数之和 (中等)##
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示列：**

> 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
    满足要求的三元组集合为：
    [
      [-1, 0, 1],
      [-1, -1, 2]
    ]
  
**解答：**
先对数组排序，然后用三个指针。i，j,k。用nums[i]固定数字。然后在后面中移动J，K使之和为-nums[i]。
要考虑去重。如果nums[i]==nums[i-1]略过，或nums[j]==nums[j-1],nums[k]==nums[k+1]等也略过。

> 时间复杂度：O(n2)，一次扫描。
  空间复杂度：O(1)，使用恒定的空间。

**c++代码：**
```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
	sort(nums.begin(),nums.end());
	if(nums.empty()||nums.front()>0||nums.back()<0)
	  return res;
	int j,k;
	for(int i=0;i<nums.size();++i){
	  int fix=nums[i];
	  if(fix>0)
	    break;
	  if(i-1>=0&& fix==nums[i-1])
	    continue;
	  j=i+1;
	  k=nums.size()-1;
	  while(j<k){
	    if(nums[j]+nums[k]==(-fix)){
	      if(k+1<nums.size()&&nums[k]==nums[k+1])
	      {
		--k;
	      }
	      else if(j-1>i&&nums[j]==nums[j-1]){
		++j;
	      }
	      else{
		res.push_back(vector<int>{nums[i],nums[j],nums[k]});
		++j;
		--k;
	      }
	    }
	    else if(nums[j]+nums[k]>(-fix)){
	      --k;
	    }
	    else{
	      ++j;
	    }
	  }
	}
	return res;
    }
};
```

## 最接近的三数之和 (中等)##
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。


**示列：**

> 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
  
**解答：**
先对数组排序，然后用三个指针。i，j,k。用nums[i]固定数字。然后在后面中移动J，K。
初始化最近值为无穷大。当三数和与目标数的距离小于最近值，则进行更新。

> 时间复杂度：O(n2)。
  空间复杂度：O(1)，使用恒定的空间。

**c++代码：**
```
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        if(nums.empty())
	  return target;
	sort(nums.begin(),nums.end());
	int res=0;
	int close=INT_MAX;
	for(int i=0;i<nums.size();++i){
	  int j=i+1;
	  int k=nums.size()-1;
	  while(j<k){
	    if(abs(nums[i]+nums[j]+nums[k]-target)<close){
	      res=nums[i]+nums[j]+nums[k];
	      close=abs(nums[i]+nums[j]+nums[k]-target);
	    }
	    if(nums[i]+nums[j]+nums[k]-target<0)
	      j++;
	    else if(nums[i]+nums[j]+nums[k]-target>0)
	      k--;
	    else
	      return target; 
	  }
	}
	return res;
    }
};
```
## 18. 四数之和(中等)##
给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
注意：
答案中不可以包含重复的四元组。

**示列：**

> 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。
    满足要求的四元组集合为：
    [
      [-1,  0, 0, 1],
      [-2, -1, 1, 2],
      [-2,  0, 0, 2]
    ]
  
**解答：**
先对数组排序，然后四个指针。固定前两个指针。然后在后面中移动后两个指针。
需要考虑重复：一个指针，如果相邻两个数相等，就要略过。

> 时间复杂度：O(n3)。
  空间复杂度：O(1)，使用恒定的空间。

**c++代码：**
```
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
	vector<vector<int>> res;
	sort(nums.begin(),nums.end());
	if(nums.empty())
	    return res;
	int n=nums.size();
	for(int i=0;i<n-3;++i){ 
	  if(i-1>=0&&nums[i]==nums[i-1])
	    continue;
	  if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target)
	    break;
	  if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target)
	    continue;
	  for(int j=i+1;j<n-2;++j){
	    if(j-1>=i+1&&nums[j]==nums[j-1])
	      continue;
	    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)
	      break;
	    if(nums[i]+nums[j]+nums[n-1]+nums[n-2]<target)
	      continue;
	    int l=j+1;
	    int r=n-1;
	    while(l<r){
	      if(nums[i]+nums[j]+nums[l]+nums[r]==target){
		res.push_back(vector<int>{nums[i],nums[j],nums[l],nums[r]});
		while(l<r&&nums[r]==nums[r-1])r--;
		while(l<r&&nums[l]==nums[l+1])l++;
		r--;
		l++;
	      }
	      else if(nums[i]+nums[j]+nums[l]+nums[r]<target){
		++l;
	      }
	      else
		--r;
	    }
	  }
	}  
	return res;
    }
};
```

## 盛最多水的容器 (中等)##
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**示列：**

> 输入: [1,8,6,2,5,4,8,3,7]
  输出: 49
  
**解答：**
使用两个指针，一个放在开始，一个置于末尾。 持续存储到目前为止所获得的最大面积。 更新最大面积，并将指向较短线段的指针向较长线段那端移动一步。如果相等，则比较中间两个

> 时间复杂度：O(n)，一次扫描。
  空间复杂度：O(1)，使用恒定的空间。

**c++代码：**
```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int s=0;
	int e=height.size()-1;
	int maxres=0;
	while(s<e){
	  maxres=max(maxres,(e-s)*min(height[s],height[e]));
	  if(height[s]>height[e])
	    e--;
	  else if(height[s]<height[e])
	     s++;
	  else
	    if(s+1<e-1 &&height[s+1]>=height[e-1])
	      s++;
	    else if(s+1<e-1 && height[s+1]<height[e-1])
	      e--;
	    else
	      ++s;
	}
	
	return maxres;
    }
};
```

## 删除排序数组中的重复项 (简单)##
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

**示列：**

> 给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。
  
**解答：**
使用两个指针，慢指针初始化为0，快指针初始化为1。 如果指针内容相等，快指针递增。否则慢指针增1，再两指针内容交换。

> 时间复杂度：O(n)
  空间复杂度：O(1)

**c++代码：**
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty())
	  return 0;
	if(nums.size()==1)
	  return nums[0];
	int pre=0;
	for(int it=1;it<nums.size();++it){
	  if(nums[it]!=nums[pre]){
	    ++pre;
	    nums[pre]=nums[it];
	  }
	}
	return pre+1;
    }
};
```

## 移除元素(简单) ##
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示列：**

> 给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
  
**解答：**
使用两个指针，慢指针初始化为数组头部，快指针初始化为0。 把快指针元素不等于val元素往头部移动。

> 时间复杂度：O(n)
  空间复杂度：O(1)

**c++代码：**
```

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.empty())
	  return 0;
	int i=0;
	for(int j=0;j<nums.size();++j){
	  if(nums[j]!=val){
	    nums[i]=nums[j];
	    ++i;
	  }
	}
	return i;
    }
};
```

## 颜色分类(中等) ##
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意:
不能使用代码库中的排序函数来解决这道题。

**示列：**

> 输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

进阶：

    一个直观的解决方案是使用计数排序的两趟扫描算法。
    首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
    你能想出一个仅使用常数空间的一趟扫描算法吗？

  
**解答：**
我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。
沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。

> 时间复杂度：O(n)
  空间复杂度：O(1)

**c++代码：**
```

class Solution {
public:
  void sortColors(vector<int>& nums) {
      int p0=0,p2=nums.size()-1,curr=0;
      while(curr<=p2){
	if(nums[curr]==0)
	  swap(nums[curr++],nums[p0++]);
	else if(nums[curr]==2)
	  swap(nums[curr],nums[p2--]);
	else
	  curr++;
      }
  }
};
```



